{"title":"Module 2: Shortest Path Algorithms & Routing Networks","markdown":{"yaml":{"title":"Module 2: Shortest Path Algorithms & Routing Networks","subtitle":"<a href=\"slides-ML.html\" target=\"_blank\"></a>","author":[{"name":{"given":"Siju","family":"Swamy"},"orcid":"0009-0004-1983-5574","email":"siju.swamy@saintgits.org","affiliations":[{"name":"Saintgits College of Engineering (Autonomous)","city":"Kottayam","country":"India","postal-code":686532}],"attributes":{"equal-contributor":false}}],"format":{"html":{"mermaid":{"theme":"dark"}},"revealjs":{"output-file":"slides-ML.html","width":960,"height":700,"css":"assets/style.css","mermaid":{"theme":"dark"}}},"jupyter":"python3","execute":{"enabled":true}},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n\n\nShortest path problems form the foundation of many modern computational systems including **navigation software, logistics planning, robotics, networking protocols, and communication infrastructures**. This module explores classical and modern shortest path algorithms used to determine optimal routing in graphs.\n\nA shortest path problem asks:\n\n> *Given a weighted graph and two vertices, what is the minimum-cost path connecting them?*\n\nFormally, for a graph  \n$$G = (V, E, w)$$  \nwith non-negative weights \\(w(u,v) \\ge 0\\), find a path from \\(s\\) to \\(t\\) minimizing\n\n$$ \\text{Cost}(P) = \\sum_{(u,v)\\in P} w(u,v). $$\n\n## Types of Graphs Relevant to Shortest Path\n\n\n| Graph Type | Description | Example |\n|------------|-------------|---------|\n| Unweighted Graph | All edges have equal cost | Social connections, BFS |\n| Weighted Graph | Costs represent time/distance/money | Maps, logistics |\n| Directed Graph | One-way movement | Internet routing |\n| Dynamic Graph | Weights change with time | Traffic congestion |\n| Probabilistic Graph | Costs uncertain / stochastic | Autonomous navigation |\n\n## 2. Shortest Path Algorithms: Overview\n\n| Algorithm | Conditions | Time Complexity | Applications |\n|-----------|------------|-----------------|--------------|\n| **BFS** (Breadth-First Search) | Unweighted graphs | \\(O(V+E)\\) | Hop distance, degree separation |\n| **Dijkstra’s Algorithm** | Non-negative weights | \\(O(E\\log V)\\) | GPS routing, OSPF networking |\n| **Bellman–Ford** | Negative edges allowed | \\(O(VE)\\) | Telecom delay optimization |\n| **Floyd–Warshall** | All-pairs shortest paths | \\(O(V^3)\\) | Multipoint routing, clusters |\n| **A\\*** | Heuristic search | Depends on heuristic | Robotics, gaming AI |\n\n### Dijkstra’s Algorithm – Core Idea\n\nDijkstra introduced a greedy algorithm (1959) to compute shortest paths by iteratively expanding the least-cost node.\n\n#### Pseudocode\n\n```bash\n\nInitialize distances to ∞, distance[source] = 0\nInsert source into priority queue Q\nWhile Q is not empty:\nu = extract-min(Q)\nFor each neighbor v of u:\nIf dist[v] > dist[u] + w(u,v):\ndist[v] = dist[u] + w(u,v)\nupdate Q\n\n```\n\n:::{.callout-note}\n### Key Property\nWorks only for **non-negative weights**.\n:::\n\n#### Hands-on Example Using `NetworkX`\n\n```{python}\nimport networkx as nx\n\nG = nx.DiGraph()\nG.add_weighted_edges_from([\n    (\"A\",\"B\",4),(\"A\",\"C\",2),(\"C\",\"B\",1),(\"B\",\"D\",5),(\"C\",\"D\",8)\n])\n\npath = nx.dijkstra_path(G, source=\"A\", target=\"D\")\ndistance = nx.dijkstra_path_length(G, \"A\",\"D\")\n\npath, distance\n```\n### Bellman–Ford Algorithm\n\nUnlike Dijkstra, Bellman–Ford can handle negative weights and detect negative cycles.\n\nRecurrence Relation\n\n$$d[v]=min(d[v],d[u]+w(u,v))$$\nRepeated for \n$V−1$ iterations.\n\n:::{.callout-note}\n### Applications\n\n1. Currency arbitrage (Forex)\n\n2. Delay-based telecom routing\n\n3. Risk-value optimization\n:::\n\n### Floyd-Warshall Algorithm (All Pair Shortest Path)\n\nDynamic programming based:\n\n$$D[i][j]=min{D[i][j],D[i][k]+D[k][j]}.$$\n\n\n:::{.callout-note}\n### APplications\n\n1. Network backbone routing tables\n\n2. Scheduling large distributed systems\n\n3. Traffic signal control\n:::\n\n### Engineering Applications\n\n| Engineering Domain | Problem                | Model                    | Solution                 |\n| ------------------ | ---------------------- | ------------------------ | ------------------------ |\n| GPS Navigation     | Fastest route          | Weighted directed graph  | Dijkstra / A*            |\n| Internet Routing   | Packet movement        | Autonomous systems graph | OSPF / BGP shortest path |\n| Robotics           | Collision-free path    | Grid graph               | A* heuristic             |\n| Smart Logistics    | Delivery optimization  | Time-cost graphs         | Multi-source Dijkstra    |\n| Airline Networks   | Minimum-cost itinerary | DAG                      | DP shortest path         |\n| Power Grids        | Load flow optimization | Weighted graph           | Min-cut / flow           |\n\n\n### Real-world Demonstration Example\n\nCompute shortest path in a mini city graph\n\n```{python}\nimport networkx as nx\n\ncities = nx.Graph()\ncities.add_weighted_edges_from([\n    (\"Kollam\",\"Kottarakkara\",22),\n    (\"Kollam\",\"Adoor\",44),\n    (\"Kottarakkara\",\"Pathanamthitta\",31),\n    (\"Adoor\",\"Pathanamthitta\",22),\n    (\"Pathanamthitta\",\"Ranni\",15)\n])\n\nnx.dijkstra_path(cities, \"Kollam\", \"Ranni\")\n\n```\n\n## Conclusion\n\nShortest path algorithms form the computational backbone of many real-world systems across engineering and technology. Beginning from classical BFS/DFS through Dijkstra and Bellman–Ford to modern heuristic search like A*, these techniques enable optimized and intelligent routing decisions essential for networks, transportation, logistics, robotics and smart cities.\n\n> Efficient routing is not merely a theoretical challenge but a fundamental driver of intelligent engineering design.\n\n\n:::: {.content-hidden when-format=\"revealjs\"}\n\nMachine learning represents a sophisticated approach to solving problems by leveraging data to inform and improve decision-making processes, contrasting sharply with traditional rule-based systems. Unlike rule-based learning, which relies on predefined rules and logic to make decisions, machine learning algorithms dynamically adapt and learn from patterns within data. This enables them to handle complex and variable inputs without explicit programming for every scenario. Essentially, machine learning is a richer computational translation of mathematical and statistical models, allowing for more flexible and accurate predictions by identifying patterns and insights that rule-based systems might overlook. A wonderful aspect of machine learning is its ability to store the learned patterns and knowledge, allowing models to be reused and refined over time for future predictions, thereby continuously enhancing their performance as more data becomes available.\n\nThe Classification of Machine Learning Algorithms is shown below.\n::::","srcMarkdownNoYaml":"\n\n## Introduction\n\n\nShortest path problems form the foundation of many modern computational systems including **navigation software, logistics planning, robotics, networking protocols, and communication infrastructures**. This module explores classical and modern shortest path algorithms used to determine optimal routing in graphs.\n\nA shortest path problem asks:\n\n> *Given a weighted graph and two vertices, what is the minimum-cost path connecting them?*\n\nFormally, for a graph  \n$$G = (V, E, w)$$  \nwith non-negative weights \\(w(u,v) \\ge 0\\), find a path from \\(s\\) to \\(t\\) minimizing\n\n$$ \\text{Cost}(P) = \\sum_{(u,v)\\in P} w(u,v). $$\n\n## Types of Graphs Relevant to Shortest Path\n\n\n| Graph Type | Description | Example |\n|------------|-------------|---------|\n| Unweighted Graph | All edges have equal cost | Social connections, BFS |\n| Weighted Graph | Costs represent time/distance/money | Maps, logistics |\n| Directed Graph | One-way movement | Internet routing |\n| Dynamic Graph | Weights change with time | Traffic congestion |\n| Probabilistic Graph | Costs uncertain / stochastic | Autonomous navigation |\n\n## 2. Shortest Path Algorithms: Overview\n\n| Algorithm | Conditions | Time Complexity | Applications |\n|-----------|------------|-----------------|--------------|\n| **BFS** (Breadth-First Search) | Unweighted graphs | \\(O(V+E)\\) | Hop distance, degree separation |\n| **Dijkstra’s Algorithm** | Non-negative weights | \\(O(E\\log V)\\) | GPS routing, OSPF networking |\n| **Bellman–Ford** | Negative edges allowed | \\(O(VE)\\) | Telecom delay optimization |\n| **Floyd–Warshall** | All-pairs shortest paths | \\(O(V^3)\\) | Multipoint routing, clusters |\n| **A\\*** | Heuristic search | Depends on heuristic | Robotics, gaming AI |\n\n### Dijkstra’s Algorithm – Core Idea\n\nDijkstra introduced a greedy algorithm (1959) to compute shortest paths by iteratively expanding the least-cost node.\n\n#### Pseudocode\n\n```bash\n\nInitialize distances to ∞, distance[source] = 0\nInsert source into priority queue Q\nWhile Q is not empty:\nu = extract-min(Q)\nFor each neighbor v of u:\nIf dist[v] > dist[u] + w(u,v):\ndist[v] = dist[u] + w(u,v)\nupdate Q\n\n```\n\n:::{.callout-note}\n### Key Property\nWorks only for **non-negative weights**.\n:::\n\n#### Hands-on Example Using `NetworkX`\n\n```{python}\nimport networkx as nx\n\nG = nx.DiGraph()\nG.add_weighted_edges_from([\n    (\"A\",\"B\",4),(\"A\",\"C\",2),(\"C\",\"B\",1),(\"B\",\"D\",5),(\"C\",\"D\",8)\n])\n\npath = nx.dijkstra_path(G, source=\"A\", target=\"D\")\ndistance = nx.dijkstra_path_length(G, \"A\",\"D\")\n\npath, distance\n```\n### Bellman–Ford Algorithm\n\nUnlike Dijkstra, Bellman–Ford can handle negative weights and detect negative cycles.\n\nRecurrence Relation\n\n$$d[v]=min(d[v],d[u]+w(u,v))$$\nRepeated for \n$V−1$ iterations.\n\n:::{.callout-note}\n### Applications\n\n1. Currency arbitrage (Forex)\n\n2. Delay-based telecom routing\n\n3. Risk-value optimization\n:::\n\n### Floyd-Warshall Algorithm (All Pair Shortest Path)\n\nDynamic programming based:\n\n$$D[i][j]=min{D[i][j],D[i][k]+D[k][j]}.$$\n\n\n:::{.callout-note}\n### APplications\n\n1. Network backbone routing tables\n\n2. Scheduling large distributed systems\n\n3. Traffic signal control\n:::\n\n### Engineering Applications\n\n| Engineering Domain | Problem                | Model                    | Solution                 |\n| ------------------ | ---------------------- | ------------------------ | ------------------------ |\n| GPS Navigation     | Fastest route          | Weighted directed graph  | Dijkstra / A*            |\n| Internet Routing   | Packet movement        | Autonomous systems graph | OSPF / BGP shortest path |\n| Robotics           | Collision-free path    | Grid graph               | A* heuristic             |\n| Smart Logistics    | Delivery optimization  | Time-cost graphs         | Multi-source Dijkstra    |\n| Airline Networks   | Minimum-cost itinerary | DAG                      | DP shortest path         |\n| Power Grids        | Load flow optimization | Weighted graph           | Min-cut / flow           |\n\n\n### Real-world Demonstration Example\n\nCompute shortest path in a mini city graph\n\n```{python}\nimport networkx as nx\n\ncities = nx.Graph()\ncities.add_weighted_edges_from([\n    (\"Kollam\",\"Kottarakkara\",22),\n    (\"Kollam\",\"Adoor\",44),\n    (\"Kottarakkara\",\"Pathanamthitta\",31),\n    (\"Adoor\",\"Pathanamthitta\",22),\n    (\"Pathanamthitta\",\"Ranni\",15)\n])\n\nnx.dijkstra_path(cities, \"Kollam\", \"Ranni\")\n\n```\n\n## Conclusion\n\nShortest path algorithms form the computational backbone of many real-world systems across engineering and technology. Beginning from classical BFS/DFS through Dijkstra and Bellman–Ford to modern heuristic search like A*, these techniques enable optimized and intelligent routing decisions essential for networks, transportation, logistics, robotics and smart cities.\n\n> Efficient routing is not merely a theoretical challenge but a fundamental driver of intelligent engineering design.\n\n\n:::: {.content-hidden when-format=\"revealjs\"}\n\nMachine learning represents a sophisticated approach to solving problems by leveraging data to inform and improve decision-making processes, contrasting sharply with traditional rule-based systems. Unlike rule-based learning, which relies on predefined rules and logic to make decisions, machine learning algorithms dynamically adapt and learn from patterns within data. This enables them to handle complex and variable inputs without explicit programming for every scenario. Essentially, machine learning is a richer computational translation of mathematical and statistical models, allowing for more flexible and accurate predictions by identifying patterns and insights that rule-based systems might overlook. A wonderful aspect of machine learning is its ability to store the learned patterns and knowledge, allowing models to be reused and refined over time for future predictions, thereby continuously enhancing their performance as more data becomes available.\n\nThe Classification of Machine Learning Algorithms is shown below.\n::::"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":true,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"ML_lesson.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","sphinx":{"config":{"html_js_files":["https://unpkg.com/mermaid@10.9.1/dist/mermaid.min.js"]},"extra_extensions":["sphinxcontrib.mermaid"]},"body-header":"This Cource is designed and implemented by Department of Mathematics\n","margin-header":"![Sharing Innovations](/images//logo.jfif)\n","theme":"yeti","title":"Module 2: Shortest Path Algorithms & Routing Networks","subtitle":"<a href=\"slides-ML.html\" target=\"_blank\"></a>","author":[{"name":{"given":"Siju","family":"Swamy"},"orcid":"0009-0004-1983-5574","email":"siju.swamy@saintgits.org","affiliations":[{"name":"Saintgits College of Engineering (Autonomous)","city":"Kottayam","country":"India","postal-code":686532}],"attributes":{"equal-contributor":false}}],"jupyter":"python3","mermaid":{"theme":"dark"}},"extensions":{"book":{"multiFile":true}}},"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":true,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","output-file":"slides-ML.html","css":["assets/style.css"]},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.7.31","auto-stretch":true,"sphinx":{"config":{"html_js_files":["https://unpkg.com/mermaid@10.9.1/dist/mermaid.min.js"]},"extra_extensions":["sphinxcontrib.mermaid"]},"body-header":"This Cource is designed and implemented by Department of Mathematics\n","margin-header":"![Sharing Innovations](/images//logo.jfif)\n","title":"Module 2: Shortest Path Algorithms & Routing Networks","subtitle":"<a href=\"slides-ML.html\" target=\"_blank\"></a>","author":[{"name":{"given":"Siju","family":"Swamy"},"orcid":"0009-0004-1983-5574","email":"siju.swamy@saintgits.org","affiliations":[{"name":"Saintgits College of Engineering (Autonomous)","city":"Kottayam","country":"India","postal-code":686532}],"attributes":{"equal-contributor":false}}],"jupyter":"python3","width":960,"height":700,"mermaid":{"theme":"dark"}}}},"projectFormats":["html"]}